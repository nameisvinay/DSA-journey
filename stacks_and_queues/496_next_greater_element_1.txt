
===========================================================================
# ğŸ§© Problem: Next Greater Element I  
ğŸ”— [Leetcode 496](https://leetcode.com/problems/next-greater-element-i/)  
ğŸ“š Topic: Stack (Monotonic Stack)  
ğŸ“ˆ Level: Easy  

===========================================================================
---

## ğŸ“„ Description  
You are given two arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`.  
For each element in `nums1`, find the **next greater element** in `nums2`.  
If it doesn't exist, return -1 for that element.

---

## ğŸ“¥ Example  
```

Input: nums1 = \[4,1,2], nums2 = \[1,3,4,2]
Output: \[-1,3,-1]
Explanation:

* For 4 â†’ no greater to the right in nums2 â†’ -1
* For 1 â†’ next greater is 3
* For 2 â†’ no greater â†’ -1

````

---

## ğŸ” Initial idea: 

    ## âŒ Brute Force (Initial Thought):
              
                We need to:  work with nums2. loop over array and check if any greater element than current is found.
                            - if found we got one greater element. to avoid duplicates , use hashmap.
                  
                ans = {}
                initalize found = False first.
                if found any greater than current update it to True and break the loop and traverse for next element.

                for i in range(len(nums2)):
                    found = False
                    for j in range(i+1,len(nums2)):
                        if nums2[i] < nums2[j]:
                            ans[nums2[i]] = nums2[j]            
                            found = True
                            break

                expected -->   {1:3 , 3:4}

                if we dont find any greater element than current simply place -1 at that index position. 
          
                          if not found:
                              ans[nums2[i]] = -1        After traversal, assign -1 to all remaining items in stack
    
                       {1:3 , 3:4 , 4:-1 , 2:-1}

            now compare with nums1 if any of nums1 element if found with greater element simply take that value.

            [ans[i] for i in nums1] which is our required result

---

                    ```python
                    # Brute-force: O(n1 * n2)
                    ans = {}
                    for i in range(len(nums2)):
                        found = False
                        for j in range(i+1,len(nums2)):
                            if nums2[i] < nums2[j]:
                                ans[nums2[i]] = nums2[j]
                                found = True
                                break
                        if not found:
                            ans[nums2[i]] = -1
                     return [ans[i] for i in nums1]
                    ````

ğŸ”» Inefficient: O(n1 * n2)

---

We can solve this using a **monotonic stack**:
- Either **right-to-left** (preferred)  
- Or **left-to-right** (also valid, but needs cleanup)

---

## âœ… Left-to-Right Stack: (my initial approach using stack)

        ### ğŸ” Logic:
        
        * Traverse from start to end
        * Stack holds elements **waiting** for their next greater
        * When a greater element comes, it becomes the NGE for stack top
        * After traversal, assign `-1` to all remaining items in stack
        
        ### âœ… Code:

            ```python
            def nextGreaterElement(nums1, nums2):
                stack = []
                ans = {}
            
                for num in nums2:
                    while stack and num > stack[-1]: #stack holding future elements. so if curr > stack[-1] then no greater element.we pop
                        prev = stack.pop()          #til we found greater than curr. if not found we assign -1. if found assign the value.
                        ans[prev] = num
                    stack.append(num)
            
                # Assign -1 for leftovers
                while stack:
                    ans[stack.pop()] = -1
            
                return [ans[num] for num in nums1]
            ```

## âœ… Right-to-Left Stack (Preferred) -- from other user solutions

        ### ğŸ” Logic:
        - Traverse `nums2` from end to start
        - Maintain a decreasing stack
        - For each element, the top of the stack is the next greater
        - If stack is empty â†’ no greater exists â†’ assign `-1`
        - we keep future elements in stack. so if current element is greater than stack element pop it.
        - we need stack element to be greater than curr. to get next greater element

    ### âœ… Code:
        ```python
        def nextGreaterElement(nums1, nums2):
            stack = []
            ans = {}
        
            for num in reversed(nums2):
                while stack and stack[-1] <= num:
                    stack.pop()
                ans[num] = stack[-1] if stack else -1
                stack.append(num)
        
            return [ans[num] for num in nums1]
        ````

        ### âœ… Pros:
                * Clean and efficient
                * No need to handle leftovers
                * Great for building full `value â†’ next greater` map

---


### âš ï¸ Note:

* Works the same but needs **extra cleanup**
* Good approach when you're processing in streaming fashion (online)

---

        ## ğŸ§  Summary
        
        | Direction     | Works? | Handle Leftovers? | Use Case                                  |
        | ------------- | ------ | ----------------- | ----------------------------------------- |
        | Right to Left | âœ… Yes  | âŒ No              | Full map building (`nums2`) â€“ cleanest    |
        | Left to Right | âœ… Yes  | âœ… Yes             | Useful for real-time stack logic problems |

---


## ğŸ¯ Takeaway

Mastering **both traversal directions** gives you flexibility across problems like:

        * `Next Greater Element I & II`
        * `Daily Temperatures`
        * `Stock Span Problem`
        * `Trapping Rain Water`
        * `Largest Rectangle in Histogram`
```

---

## ğŸ§  Time & Space Complexity

* **Time**: O(n1 + n2)
* **Space**: O(n2) for stack and hashmap

---

## âš ï¸ Mistakes & Learnings

* âŒ Forgot to traverse `nums2` in reverse (essential for monotonic stack)
* âŒ Tried solving `nums1` directly without preprocessing `nums2`
* âœ… Learned how monotonic decreasing stacks work
* âœ… Realized this pattern appears in many stack-based problems

---

## ğŸ¯ Final Takeaway

This problem uses a **reusable pattern** that appears in:

* ğŸ” Next Greater Element II (circular)
* ğŸŒ¡ï¸ Daily Temperatures
* ğŸ“‰ Stock Span Problem
* ğŸ§± Trapping Rain Water
* ğŸ—ï¸ Largest Rectangle in Histogram

Mastering this pattern strengthens your DSA core significantly. ğŸ’ª

---

```
