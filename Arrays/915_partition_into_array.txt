Sure buddy! Here's your complete **GitHub-ready Markdown note** for:

---

````markdown
==================================================================
ğŸ§© Problem: 915. Partition Array into Disjoint Intervals  
ğŸ”— Link   : https://leetcode.com/problems/partition-array-into-disjoint-intervals/  
ğŸ“š Topic  : Arrays  
ğŸ“ˆ Level  : Medium  
==================================================================

### ğŸ“„ Description:
Given an integer array `nums`, partition it into **two contiguous subarrays** `left` and `right` such that:

- Every element in `left` is **less than or equal to** every element in `right`.
- `left` and `right` are both **non-empty**.
- Return the **smallest possible length** of `left` after such a partition.

---

### âœ… Constraints:
- 2 â‰¤ `nums.length` â‰¤ 10âµ  
- 0 â‰¤ `nums[i]` â‰¤ 10â¶  
- A valid partition **always exists**.

---

### âœ… Approach: Greedy + Prefix Max
We need to find the **smallest** left subarray such that:
```text
max(left) â‰¤ min(right)
````

#### ğŸ”‘ Key Intuition:

* We maintain:

  * `leftMax`: Maximum value in the current left partition.
  * `overallMax`: Maximum value seen so far.
* While iterating:

  * If `nums[i] < leftMax`, this value **cannot be** in the right â†’ **we extend left**.
  * In this case, update:

    * `leftMax = overallMax`
    * `partitionIdx = i`

---

### ğŸ§  Dry Run:

#### ğŸ”¢ Input:

```py
nums = [90, 47, 69, 10, 43, 92, 31, 73, 61, 97]
```

| i | nums\[i] | overallMax | leftMax | Condition (nums\[i] < leftMax) | Action                                  |
| - | -------- | ---------- | ------- | ------------------------------ | --------------------------------------- |
| 0 | 90       | 90         | 90      | -                              | Init                                    |
| 1 | 47       | 90         | 90      | âœ… Yes                          | Extend left to i=1                      |
| 2 | 69       | 90         | 90      | âœ… Yes                          | Extend left to i=2                      |
| 3 | 10       | 90         | 90      | âœ… Yes                          | Extend left to i=3                      |
| 4 | 43       | 90         | 90      | âœ… Yes                          | Extend left to i=4                      |
| 5 | 92       | 92         | 90      | âŒ No                           | Update overallMax = 92                  |
| 6 | 31       | 92         | 90      | âœ… Yes                          | Extend left to i=6, update leftMax = 92 |
| 7 | 73       | 92         | 92      | âœ… Yes                          | Extend left to i=7                      |
| 8 | 61       | 92         | 92      | âœ… Yes                          | Extend left to i=8                      |
| 9 | 97       | 97         | 92      | âŒ No                           | Done                                    |

âœ… Final left partition ends at index `8` â†’ length = `9`

---

### ğŸ§ª Final Split:

```text
left  = [90, 47, 69, 10, 43, 92, 31, 73, 61]   (max = 92)
right = [97]                                  (min = 97)
```

âœ”ï¸ Valid partition: `92 â‰¤ 97`

---

### âœ… Code (Python):

      ```python
      def partitionDisjoint(nums):
          leftMax = nums[0]
          overallMax = nums[0]
          partitionIdx = 0
          
          for i in range(1, len(nums)):
              overallMax = max(overallMax, nums[i])
              if nums[i] < leftMax:
                  leftMax = overallMax
                  partitionIdx = i
          
          return partitionIdx + 1
      ```

---

### ğŸ” Time & Space Complexity:

* **Time:** O(n)
* **Space:** O(1)

---

### ğŸ§  Takeaway:

> Always extend `left` whenever an element breaks the condition.
> Use `overallMax` to update `leftMax` only **when needed**.

---

```

---
